from __future__ import annotations

import json
import logging
from typing import Any, Dict, Optional

try:
    from openai import AsyncOpenAI  # type: ignore import-not-found
except Exception:  # pragma: no cover - library optional at runtime
    AsyncOpenAI = None  # type: ignore assignment

logger = logging.getLogger(__name__)

_SYSTEM_PROMPT = """You are an assistant that reads raw trading signals written in Portuguese and extracts a concise JSON summary.

Output strictly a JSON object with the following fields:
- symbol: uppercase asset ticker/pair (example: EURUSD).
- action: BUY or SELL. Use BUY for keywords like COMPRAR/LONG; SELL for VENDER/SHORT; NONE when direction is absent.
- entry: price level as string (e.g. "1.08400"). If the text orders entry "a mercado", "market", or only mentions ranges/points, respond with the literal string "MARKET".
- take_profit: array of price strings in ascending order. Use an empty array when no explicit target is present.
- stop_loss: price string. If missing, respond with "NA".
- timeframe: timeframe mentioned (e.g. "M30"), or "NA" if absent.

Guidelines:
- Ignore decorative characters such as emojis or repeated separators.
- When the message includes prices separated by line breaks, associate the first price after the instruction "ENTRAR" with entry (if numeric) and any subsequent TP/SL instructions with the respective price on the next line.
- Convert Portuguese terms (COMPRAR/VENDER, STOP/LOSS, TAKE PROFIT, TEMPO GRÁFICO, HORÁRIO, etc.) into the required English keys.
- Do not create values if they are not in the message; prefer "MARKET" or "NA" accordingly.
- Never wrap the JSON in markdown or additional text.
"""


class SignalParser:
    """Wrapper around OpenAI Responses API to transform raw signals into structured JSON."""

    def __init__(
        self,
        api_key: Optional[str],
        model: str,
    ) -> None:
        self._api_key = api_key
        self._model = model
        if api_key and AsyncOpenAI is not None:
            self._client = AsyncOpenAI(api_key=api_key)
        else:
            self._client = None
            if api_key:
                logger.warning("OpenAI client unavailable even though API key is set.")

    @property
    def configured(self) -> bool:
        return self._client is not None

    async def parse(self, message: str) -> Dict[str, Any]:
        if not message or not message.strip():
            raise ValueError("Cannot parse empty signal message.")
        if not self._client:
            raise RuntimeError("OpenAI API key is not configured.")

        try:
            response = await self._client.responses.create(
                model=self._model,
                input=[
                    {"role": "system", "content": _SYSTEM_PROMPT},
                    {"role": "user", "content": message.strip()},
                ],
                temperature=0.1,
            )
        except Exception as exc:  # pragma: no cover - depends on external API
            logger.exception("OpenAI API error while parsing signal.")
            raise RuntimeError(f"OpenAI request failed: {exc}") from exc

        # The Responses API returns a list of outputs; gather concatenated text blocks.
        try:
            json_payload = getattr(response, "output_text", None)
            if not json_payload:
                output_blocks = getattr(response, "output", []) or []
                text_chunks = []
                for block in output_blocks:
                    for item in getattr(block, "content", []):
                        if getattr(item, "type", None) == "output_text":
                            text_chunks.append(item.text)
                        elif getattr(item, "type", None) == "text":
                            text_chunks.append(item.text)
                json_payload = "".join(text_chunks).strip()
            if not json_payload:
                raise ValueError("Empty JSON payload returned by OpenAI.")
            text = json_payload.strip()
            if not text.startswith("{"):
                start = text.find("{")
                end = text.rfind("}")
                if start != -1 and end != -1 and end > start:
                    text = text[start : end + 1]
            data = json.loads(text)
            return self._normalise_payload(data)
        except Exception as exc:
            logger.exception("Failed to parse JSON payload generated by OpenAI.")
            raise RuntimeError(f"Invalid JSON returned by OpenAI: {exc}") from exc

    @staticmethod
    def _normalise_payload(raw: Dict[str, Any]) -> Dict[str, Any]:
        def _string(value: Optional[Any], fallback: str = "NA") -> str:
            if value is None:
                return fallback
            text = str(value).strip()
            return text or fallback

        symbol = _string(raw.get("symbol"), "NA").upper()

        action_raw = _string(raw.get("action"), "NONE").upper()
        action_map = {
            "COMPRAR": "BUY",
            "COMPRA": "BUY",
            "BUY": "BUY",
            "LONG": "BUY",
            "VENDER": "SELL",
            "VENDA": "SELL",
            "SELL": "SELL",
            "SHORT": "SELL",
        }
        action = action_map.get(action_raw, action_raw if action_raw in {"BUY", "SELL"} else "NONE")

        entry_raw = _string(raw.get("entry"), "MARKET")
        entry = entry_raw.upper() if entry_raw.strip().lower() in {"market", "a mercado", "market order"} else entry_raw
        if entry != "MARKET":
            entry = entry.replace(" ", "")

        take_profit_value = raw.get("take_profit")
        if isinstance(take_profit_value, list):
            take_profit = [
                _string(item)
                for item in take_profit_value
                if _string(item) not in {"", "NA"}
            ]
        elif isinstance(take_profit_value, str):
            take_profit = [_string(take_profit_value)] if take_profit_value.strip() else []
        else:
            take_profit = []

        stop_loss = _string(raw.get("stop_loss"))
        timeframe = _string(raw.get("timeframe"), "NA")

        if not take_profit:
            take_profit = []

        return {
            "symbol": symbol,
            "action": action,
            "entry": entry if entry else "MARKET",
            "take_profit": take_profit,
            "stop_loss": stop_loss,
            "timeframe": timeframe,
        }
